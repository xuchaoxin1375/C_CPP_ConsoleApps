/* 题目描述
输入一个长度不超过100的字符串,删除串中的重复字符。

输入要检查的字符串,长度不超过100个字符:abacaeedabcded.
输出删除重复字符后的字符串:abced.
样例输入saas
样例输出sa
 */
 //握手模型;最理想地输入的比较次数规模(1+2+..+n)地规模(类似勾股数枚举)
 
 #include <stdio.h>
 #include <string.h>
 #define N 200
 int main()
 {
     char a[N];  //存储字符串.
     int i,j,n;
     char k;
     gets(a);//读入字符串.

     //遍历输入的字符串(一定规模内的)

     //控制外层循环的趟次,并提供趟次号变量i
     int len=strlen(a);
     for(i=0;i<strlen(a);i++)
     {
         const char tmp = a[i];
         for(n=0;n<i;n++)//内层遍历从i=1开始进入,控制各趟次内需要执行循环的次数
         {
             if(tmp==a[n])  //n比i更加常变:每趟比较中,i只有相同的一个值,而n要遍历i个值.;每一趟中,i就作为一个标杆
             {  //a[i] == a[n]意味着出现了重复字符;
                 //下面这个循环将下一个值替代上一个值,即相当于把位置i之后的那部分子字符串向前集体地挪了一格,从而减小重复字符串的规模
                 for(j=i;j<len;j++)
                 {
                     a[j]=a[j+1]; //迭代a[j] ,并对字符数组(字符串)做出了该改变
                 }//for()

                 i=i-1;//将这轮发生处理的循环重新执行??/(迭代),最外层i++会加回到这个i,至于为啥放在这里,
                 //当然可以再此 break;//直达外层for
             }//刚从此处离开后,n++(n将+1),之后,在这一轮发生地if将是上一轮规模地比较,不会再更改字符串了,直到外层地i++后重新开始
         }//for()
         //刚从此处离开后,会执行在外面一层地循环变量迭代(i++)

     }//for()

     puts(a);
     return 0;
 }