/*（3）思考*/
//（1）通用的数据堆栈
//上述实现的栈只能用来保存整型数据，如果想要处理其他类型的数据，该做怎样的修改？
//typedef int SElemType; /* SElemType 类型根据实际情况而定，这里假设为int */
//
//
//
///* 顺序栈结构 */
//typedef struct
//{
//    SElemType data[MAXSIZE];
//    int top; /* 用于栈顶指针 */
//}SqStack;

/*（2）动态分配空间的栈(借助realloc()扩充空间)
上述实现的是一个用静态数组作为数据存储空间的栈，当入栈数据量超过其最大容量时，该栈不能正常工作。

我们希望将存储空间改为动态存储空间，当空间不足时，自动将空间扩大。
这时，堆栈数据结构类型可以定义如下：*/
/*typedef struct {
    int* pElem;     // 用来保存动态空间的地址
    int top;         // 指示栈顶位置的标识量
    int size;        // 动态空间当前长度的标识量
}intStack;*/

/*
初始化时，为堆栈开辟一个固定大小的数组空间。
当入栈时，如果存储空间已满，则重新开辟一个更大的数组空间（通常为原空间的两倍大小），
把原数组空间中存储的元素拷贝到新数组空间中，并用新数组空间代替原数组空间作为堆栈的存储空间。
尝试实现基于动态数组的堆栈及其常用算法。*/
/*（3）链栈
无论是使用数组还是动态分配，都需要保留一块连续空间。当栈所需存储的数据量未知时，这两种方式的栈在使用上都不够灵活。
而采用链栈，能克服上述缺点。

链栈是用链式形式来存储栈数据的栈，可以看做一种特殊形式的链表，两者的联系和区别如下所述：
1）链栈是没有专用头结点的特殊链表；(只在链表头部进行插入或删除，故不必附设头结点)
2）栈中的数据分别存储于链表中的每一个结点中，栈顶指针指向当前栈顶结点，相应于链表的头指针。

3）入栈相当于在链表的头部插入结点；
4）出栈相当于将当前链表的头结点移除；

5）当栈顶指针为空时，栈为空；
6）一般情况下，不需要考虑栈满的状态；

请根据以上描述，实现一个链栈。并思考一下，当用链栈来解决下面部分的应用时，跟前两种方式实现的堆栈有无区别？
（1）堆栈的应用
目标：应用堆栈解决实际问题。在应用堆栈时，需要在相关应用的源代码前包含 前述部分中 栈的实现代码。
（1）利用栈将一个整数序列逆序输出
因栈有“先进后出”的特点，可将整数序列先全部压入栈，然后逐一出栈并输出。
整数序列以数组的形式存储，该数组作为函数参数，
序列中数据的个数n亦作为参数。*/
///* 链栈结构 */
///*时类型易于更换(通用)*/
//typedef int SElemType;
///*定义不同链表的结点结构*/
//typedef struct StackNode
//{
//  
//    SElemType data;
//    struct StackNode* next;
//
//}StackNode, * LinkStackPtr;/*后一个类型名LinkStackPtr即:struct StackNode * (这么一种指针类型)*/
//
//typedef struct
//{
//    LinkStackPtr top;/*指示链栈顶的标识指针*/
//    //int count;
//}LinkStack;

void  ReverseData(int *a) // 形参接收一个整数数组
{
    sta s;  // 定义一个栈变量实例s
    int e;

    // 使用之前需要初始化该栈s
    stack;

    // 循环遍历该整数序列，将所有数据入栈
    ;

    // 循环调用Pop函数将数据出栈，保存到e中，并printf输出e，直        // 到Pop出错为止
    while ((e = ) != )
        ;
}

// 测试， 使用实际例子测试上述函数是否正常工作
void main()
{
    int a[10] = { 0,1,2,3,4,5,6,7,8,9 };
    ;  // 调用ReverseData函数
}
（2）利用栈实现八进制转换
编写一个函数，将一个十进制整数转换为八进制形式输出。比如输入十进制的“10”，该函数输出“12”。
void  ConvertOCT()
{
    ; // 定义一个栈变量实例s
    int e;

    // 使用之前需要初始化该栈s
    ;

    // 循环：若该整数不为零，则将其整除8的余数入栈，同时将该整
    // 数值赋值为整除8之后的倍数
    ;

    // 循环：Pop出栈一个数据到e，若e为正常数据，printf输出e
    while ((e = ) != )
        ;
}
// 测试， 使用实际例子测试上述函数是否正常工作
void main()
{
    // 调用ConvertOCT函数，输出10，100等数据的八进制数
    ;
}
思考：将此函数改写，使之可以输出十进制整数的十六进制数据形式。
（3）括号匹配
利用栈编写满足下列要求的括号匹配检验程序：假设表达式中允许包含两种括号：圆括号和方括号，其嵌套的顺序随意，即([]()) 或[([][])]等为正确的格式，[(]或([())或(()]) 均为不正确的格式。输入一个包含上述括号的表达式，检验括号是否配对。
    void check() // 对于输入的任意一个字符串，检验括号是否配对
{
    ; // 定义一个栈变量实例s
    char str[80], * p, e;

    // 使用之前需要初始化该栈s
    ;

    printf("请输入表达式\n");
    __________________________________;

    p = str;
    while (*p) // 没到串尾
    {
        switch (*p)
        {
            // 若是左括号，则入栈，且p++
        case '(':
        case '[':_______________________;
            break;

            // 若是右括号,则弹出栈顶元素，保存到e
        case ')':
        case ']': _________________________;

            // 若出栈正常，则判断*p 与 e 是否匹配。若不匹配，则                 // 输出不匹配信息， 并结束本函数， 否则p++
        {
            // your multiple lines code
        }
        break;

        // 其它字符不处理，指针向后移
        default: ______________________;
        } // end switch
    } // end while

    if (__________) // 字符串结束时栈空
        printf("matching\n");
    else
        printf("lack of right parenthesis\n");
} // end check

// 测试样例
/*[第一组自测数据]               [第二组自测数据]
  [键盘输入]                    [键盘输入]
  8*[3*(35-23)]↙                67-[235/ (36+89]↙
  [正确输出]                    [正确输出]
  matching                     isn’t matched pairs
*/
void main()
{
    ;
}
（4）利用栈来判断一个字符串是否是“回文”
所谓“回文”，即顺向读和逆向读都相同的文字，如“abcba”，试编写一个函数，读入一个字符串，利用栈判断其是否为“回文”，若是返回1，否则返回0。
int  IsLoop()
{
    /**************************************************
思路：将字符串的字符全部入栈，然后再逐一出栈，每出栈一个即与原字符串相应位置的字符进行比较，若不相等则返回0；若全相等，则返回1。
   *****************************************************/
   //your multiple lines code.......
}

// 测试， 使用实际例子测试上述函数是否正常工作
void main()
{
    // 定义几个回文和非回文的字符串例子，调用IsLoop函数判断并输
   // 出是否回文的信息
    ;
}
思考：前面对栈的定义可知该栈存储整型数据，本例需保存字符型数据，需对栈定义做修改吗？如果要改，怎么改？
（5）综合练习 － 迷宫问题
求迷宫中从入口到出口的所有路径是一个经典的程序设计问题。由于计算机解迷宫时，通常用的是“穷举求解”的方法，即从入口出发，顺某一方向向前探索，若能走通，则继续往前走；否则沿原路退回，换一个方向再继续探索，直至所有可能的通路都探索到为止。为了保证在任何位置上都能沿原路退回，显然需要用一个先进后出的结构来保存从入口到当前位置的路径。因此，在求迷宫通路的算法中应用“堆栈”是合适的。
假设迷宫如下图1所示，图中的每个方块或为通道（以空白方块表示），或为墙（以带阴影的方块表示）。所求路径必须是简单路径，即在求得的路径上不能重复出现同一通道块。



图1 迷宫问题
（1）该迷宫可以用二维数组表示，定义如下：
typedef struct {
    // ‘#’表示 墙，’=’表示未经过的通道，’*’表示已经过通道，’!’表示绝
    // 路。初始状态下为‘#’或者’=’
    char arr[10][10];
}MazeType;
根据图1所示，编写一个函数，对迷宫数组进行初始化。
（2）位置定义如下：
typedef struct {
    int r;   // 行坐标
    int c;   // 列坐标
}PosType;
（3）经过路径中的通道块结点信息定义如下：
typedef struct {
    int ord;  // 通道块在路径上的序号
    PosType  seat; // 通道块在迷宫中的坐标位置
    int dir; // 从此通道块走向下一个通道块的方向            
}ElemType;

根据以上类型定义，实现一个能容纳ElemType类型数据的栈。
（4）写一个函数，判断迷宫中的某个位置是否可通过。
int pass(MazeType* pMyMaze, PosType CurPos)
{
    // 如果当前位置为’=’，返回1， 否则返回0
}
（5）写一个函数，将迷宫中的某个位置标记为已通过
void footPrint(MazeType* pMyMaze, PosType CurPos)
{
    // 当前位置标记为’*’
}
（6）写一个函数，将迷宫中的某个位置标记为绝路
void blockedPrint(MazeType* pMyMaze, PosType CurPos)
{
    // 当前位置标记为’!’
}
（7）写一个函数，根据当前位置和探测方向，返回下一个探测位置
PosType  nextPosition(PosType CurPos, int dir)
{
    PosType nextPos;
    // 怎么根据 dir 得到  nextPos ？？
    return nextPos;
}
（8）给定出发位置和出口位置，根据以上栈实现和相关函数写出在迷宫中求路径的函数。
int mazePath(PosType CurPos, int dir)
{
    // ok, 看你们的了
}
（9）用图1所示迷宫验证。
void main()
{
    // 初始化一个迷宫，使用到一个栈，你还需要什么？
    // 走吧~~~
    // $*^^)&_)*)*)(^%$^^#%^&^**%
    // 最终，你的路径存到栈里了吗？但怎么按照出发顺序输出这个路
    径呢？？？
        // 也许，你需要更多一个栈．．．
}


