/* (首尾)循环扫描 */
for (i = 0; t < m - 1; i++) //运行m次
{
    /* 该编号的同学是否已被抹去/有效,若有,使所报数码j++ */
    if (identifier[i] != 0)
        j++;

    if (j == 4) //所报数值累计到4的同学://而且每达到4,重置j= 0;
    {
        *(p + i) = 0; //赋值位0表示离开/抹去

        j = 0; //重置数码记录器
        t++;   //记录被抹去了多少位同学.当该数值达到n-1时,则只剩下一个同学了,结束循环
    }
    /* 判断是否到了结尾identifier[m-1] 了(最后一个元素的索引 m-1),处理回头问题. :
        通过重置i=-1为啥不是0?,因为回到for的时候会i++的identifier[0]..,*/
    if (i >= m - 1)
        i = -1;
}

/* 循环变量回归扫描(来回端点不重复.) */
//在外头引入方向变量change来辅助控制i的逆向变化.
 if( i < n -1   && change ==  0)/* i 从0 开始.增加 */
            {
                i++;
                /* 跳出循环前,改变下change */
                if(i == n - 1 )
                {
                    change = 1;
                    /* 监视内部过程. */
                    // /* 如果这里的不定义for 专属的i,那会造成上面的含i式紊乱. */

                }
            }

            else/* i 从n-1开始递减 */
            {

                i--;
                /* 跳出循环前,改变下change */
                if (i == 0)
                {
                    change = 0;
                    //  /* 监视内部过程. ,但注意,是从遵从s型来回看,而并不总是从前往后看*/
                    // for (int i = 0; i < n; i++)
                    // {
                    //     if (*(ptr + i) != 0)
                    //     {
                    //         printf("%d ", *(ptr + i));
                    //     }
                    // }
                    // printf("\n");
                }
            }
/* 用指针读入一系列的字符串 */

        int k = 50;   
        char* p = (char*) malloc(sizeof(char)*k*k);
        char* q = p;//拷贝初始地址以备用.

        for(int i = 0;i<n;i++)
        {
            scanf("%s",p);
            p += k;
        }
        p = q;//将指针回拨到初始位置(之前由于读入数据导致偏移.


