//program 12.1.2.2.cpp   构造函数和数组
#include<iostream>
using namespace std;/*是一个语句*/
class  CTest {
public :
	int a;
	int m_=-1, n_=-1;
public:
		/*没有返回值且和类同名的得构造函数可以定义在类里头(但是要区别于类的成员函数(有一定类型的返回值,函数名称也可以各种各样.*/
	CTest(int n) { cout << "构造函数(1)" << endl; a = 1; }           //构造函数(1)
	CTest(int n, int m) { cout << "构造函数(2)" << endl; a = 2; n_ = n; m_ = m; }    //构造函数(2) 
		CTest() { cout << "构造函数(3)" << endl; a = 3; }                 //构造函数(3)
};
int main(){
	CTest  array1[3] = {
		1,/*1作为参数传递给构造函数以初始化array[0]:调用了(1)*/
		CTest(1,2)/*说明构造函数也可以被人为的调用(调用了(2)),初始化了array2[1]*/
		/*第三个位置没有指定初始化参数,调用默认构造函数(3)初始化了array2[2]*/
	};	// 三个元素分别用构造函数(1),(2),(3)初始化 
	cout << "array1[3] ended!" << endl;
	/*一个数组中的不同对象元素可以指定使用不同的构造函数类初始化,未必都是用同一个构造函数,由传入的参数(类型+数量)来决定.*/
	CTest  array2[3]={ 
		CTest(2,3), /*调用了(2) 初始化了array2[0];注意(2,3)实参列表是为了调用对应的构造函数(2)(这个构造函数需要两个实参来初始化一个array2[]数组的一个元素*/
		CTest(1,2),/*调用了(2)初始化了array2[1]*/
		1/*调用了(1)初始化了array2[2]*/
	}; //三个元素分别用(2),(2),(1)初始化 
	cout << "array2[3] ended!" << endl;

	/*这是一个指针数组:*/
	CTest * pArray[3] = { 
		/*new运算符会返回一个新申请的内存空间的地址*/
		new CTest(4), /*调用了(1)*/
		new CTest(1,2)/*调用了(2)*/
		/*pArray[2]的地址没有得到初始化,pArray本身又不是存储CTest类对象的数组,不会生成第三个对象.*/
	};
	delete pArray[0], pArray[1];
     //两个元素指向的对象分别用 (1),(2)初始化 
	/*先对pArray[0]和pArray[1]进行了初始化，把它们初始化为指向动态分配的CTest对象的 指针(地址)。
而这两个动态分配出来的CTest对象，又分别是用构造函数（1）和构造函数（2）初始化的。
至于pArray[2]没有初始化，其值是随机的，不知道指向哪里。
所以该数组最终生成了两个CTest对象，而不是3个所以也只调用CTest类的构造函数两次。*/
	cout << "array3[3] ended!" << endl;

	return 0;
}

